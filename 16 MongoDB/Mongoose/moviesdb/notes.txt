Till now, we've been typing our Mongo commands in the shell. We need to connect a Node app to Mongo.
Drivers -> These are ways to connect MongoDB to languages like C++, Rust

For Javascript, it's a tool called Mongoose
It's an ODM -> Object Document Mapper (it converts data coming from database into usable JavaScript objects)
We can define a pre-set schema and enforce it.

For SQL databases, we have ORM -> Object Relation Mapper (takes SQL data and maps it for programming languages)

> Keep the docs open, because we only do it once per project

Don't use .load script.js
Use node -i -e "$(< index.js)" in Bash


                        FIRST MODEL IN MONGOOSE

They are just javascript classes, that represent information in a collection
Schema -> A blueprint of the data, hidden: data, name: String

const Movie = mongoose.model("Model", moviesSchema) -> creates a Mongo collection called models (lowercases and pluralizes automatically)
and creates a Movie class. The name of the connection MUST have first letter capitalized and singular

> insertMany

It returns a promise, so we can use .then and .catch. It's a model method

> find(), findById(), findOne()
    These operations take time. Treat it like a promise (even though they're not), so we can use .then()
    It is a 'then-able' object (you can put .then())

    Movie.find({ condition }).then(...)

> findById() - VERY commonly used in an express app.
            app.get('/resourse/:id')

For this, just write Movie.findById(id).then()

                    UPDATING

update, updateOne, updateMany() -> They don't resolve, they don't return the updated object.
They will just tell you that ok we have updated this
updateOne() updates the first thing that matches the query

*** ALL THESE COMMANDS ARE SUPPOSED TO BE WRITTEN IN THE NODE REPL, NOT MONGOSH
AFTER RUNNING A COMMAND, CONFIRM BY LOOKING AT THE MOVIE IN MONGOSH

findOneAndUpdate() -> it will give us the object with the updated information
                      But it has a bug, it will return the old version. To get the option one, you have to pass
                      an option {new: true}

You may get a deprecation warning

    DELETING

.delete({}) -> doesn't give us anything back, only the deleted count.
.remove() doesn't exist anymore
.findOneAndRemove(), .findByIdAndRemove()...

